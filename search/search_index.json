{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"THIS DOCUMENTATION IS STILL IN DEVELOPMENT, SO THERE MAY BE SOME BUGS IN IT Logicboard SoM Hardware and Software Documentation Reference Design Images. Version 1.0.0 Size - 50mm x 50mm PCB 3D View PCB Layout (Top Layer) Actual PCB Version 2.0.0 Size - 42mm x 42mm PCB Layout (Top Layer) PCB 3D View Actual PCB V1 and V2 Size Difference Target Audience This documentation is targeted at embedded engineers who want to design a system around the STM32MP15x series microprocessors. In this documentation, I've put together a broad overview of what's involved in designing a system around ST-Microelectronics STM32MP15x series microprocessors, and then a dive into some specific parts you should check out \u2014 and others you should avoid. What is a Logicboard? Logicboard is a System on Module (SoM) that includes ST-Microelectronics Dual Arm Cortex-A7 core operating at 800 MHz + Cortex\u00ae-M4 core running at 209 MHz, DDR3L Memory, eMMC Flash, and power circuits. Key Features of the SoM STM32MP157 Arm\u00ae-based dual Cortex\u00ae-A7 32 bits + Cortex\u00ae-M4 32 bits MPU 4-Gbit (512MB), DDR3L, 16 bits RAM 4GB eMMC Flash Wi-Fi\u00ae (2.4GHz) and Bluetooth Low Energy 5.0 (next revision) Form factor: 42mm x 42 mm Module Key Features of Carrier Board Gigabit Ethernet BLE 5.0 USB-C OTG USB-A Host Micro SD-Card 12V Power Supply Barrel Jack MIPI-DSI Port RGB LCD Port ST-Link Debug Boot Switch Peripherals (LEDs, Push Buttons) GPIO Expansions Why am I doing this? I know that there are lots of people \u2014 especially hobbyists and even professional engineers who are thinking, \u201cI do all my embedded Linux development with Raspberry Pi boards and BeagleBone Black DKs \u2014 Why do I need this SoM?\u201d Yes, Raspberry Pi and Beaglebone Black SBCs, on the surface, look similar to some of these parts: they run Linux, you can attach displays to them, do networking, and they have USB, GPIO, I2C, and SPI signals available. Now if you dig a bit deep and see, Raspberry Pi's processor BCM2711 was custom-made, from the ground up, to go into smart TVs and set-top boxes \u2014 it\u2019s not a general-purpose embedded Linux application processor. This processor has video decoding and graphics acceleration, built-in HDMI transmitters that can drive dual 4k displays but just two PWM channels and not even a single ADC input. Plus you cannot run real-time tasks on this board and this beast consumes a lot of power. So it isn\u2019t generally suited for embedded Linux work. They are primarily designed to make commuting accessible to everyone. Of course, there are workarounds \u2014 like I2C-interfaced PWM chips, SPI-interfaced ADCs, or LCD modules with HDMI receivers \u2014 but they involve external hardware that adds power, bulk, and cost. If you\u2019re building a quantity-of-one project and you don\u2019t care about these things, then maybe the Pi is the right choice for the job, but if you\u2019re prototyping a real product that\u2019s going to go into production someday, you\u2019ll want to look at the entire landscape before deciding what\u2019s best. Some parts of the aforementioned shortcomings hold true for Beaglebone Black also. Although this SBC is ideal for embedded Linux work, you cannot run Real-time applications in them (Okay! you can, but it is quite difficult). And when it comes to production, you've got to design your product from scratch which increases, time to market, project costs, development risks etc. I believe this will be a risky investment for entrepreneurs willing to put everything on the line. On top of everything I mentioned, HDMI is of no use to an embedded Linux developer, as all LCDs use parallel RGB, LVDS, or MIPI as interfaces. Let's get started When you pick a Microcontroller, you should pick the right part for the job and not be afraid to learn whole new software ecosystems. Now, the best part of working with Microprocessors is that once you\u2019re booted into Linux on basically any Microprocessors, they become identical development environments. As long as your processor checks off the right boxes, your application code won\u2019t know if it\u2019s running on an ST or a Microchip part \u2014 even if one of those is a brand-new dual-core Cortex-A7 and the other is an old ARM9. Your I2C drivers, your GPIO calls \u2014 even your V4L-based image processing code \u2014 will all work seamlessly. At least, that\u2019s the sales pitch. Getting a Microprocessor booted is a completely separate experience, and that's what we'll be concentrating on. For now, I\u2019m focusing heavily on hardware design. These chips vary considerably in PCB Design difficulty when compared to a traditional Microcontroller. I intentionally designed these boards from scratch rather than starting with the Manufacturer's CAD files. This approach helped me to understand the little intricacies of the MPU, as well as optimize the design for cost and hand-assembly. Later in this documentation, I'll include some pictures of the boards and screenshots of the layouts to illustrate some points. Before we begin, let's take a quick detour and study some basics. Microcontroller vs Microprocessor The first thing you'll notice if you're coming from microcontrollers is that Linux doesn't normally work on Cortex-M, 8051, AVR, or other popular microcontroller architectures. Rather, we use application processors, such as the Arm Cortex-A, MIPS, and other variants. The most notable difference between these application processors and microcontrollers is that microprocessors include a memory management unit (MMU), whereas microcontrollers do not. Although you can run Linux without an MMU, but it's not recommended. Aside from the MMU, the distinction between MCUs and MPUs is becoming increasingly blurry. Modern application processors share many of the same peripherals as microcontrollers, and high-end Cortex-M7 microcontrollers offer clock speeds that are comparable to entry-level application processors. Choosing Linux Why is Linux so pervasive? And why does something as simple as a TV need to run something as complex as Linux just to display streaming video on a screen? The simple answer is Your TV is not simply displaying a video stream as the old analog sets used to do. The stream is digital, possibly encrypted, and it needs processing to create an image. Your TV is connected to the internet. It can receive content from smartphones, tablets, and home media servers. It can be (or soon will be) used to play games and so on. You need a full operating system to manage this degree of complexity. Here are some points that drive the adoption of Linux: Linux has the necessary functionality. It has a good scheduler, a good network stack, support for USB, Wi-Fi, Bluetooth, many kinds of storage media, good support for multimedia devices, and so on. It ticks all the boxes. Linux has been ported to a wide range of processor architectures, including some that are very commonly found in SoC designs \u2013 Arm, MIPS, x86, and PowerPC. Linux is open source, so you have the freedom to get the source code and modify it to meet your needs. You, or someone working on your behalf, can create a board support package for your particular SoC board or device. You can add protocols, features, and technologies that may be missing from the mainline source code. You can remove features that you don't need to reduce memory and storage requirements. Linux is flexible. Linux has an active community; in the case of the Linux kernel, very active. There is a new release of the kernel every 8 to 10 weeks, and each release contains code from more than 1,000 developers. An active community means that Linux is up to date and supports current hardware, protocols, and standards. Open source licenses guarantee that you have access to the source code. There is no vendor tie-in. For these reasons, Linux is an ideal choice for complex devices. When not to choose Linux Is Linux suitable for your project? Linux works well where the problem being solved justifies the complexity. It is especially good where connectivity, robustness, and complex user interfaces are required. However, it cannot solve every problem, so here are some things to consider before you jump in: Is your hardware up to the job? Compared to a traditional real-time operating system (RTOS) such as VxWorks or QNX, Linux requires a lot more resources. It needs at least a 32-bit processor and lots more memory. I will go into more detail in the section on typical hardware requirements. Do you have the right skill set? The early parts of a project, board bring-up, require detailed knowledge of Linux and how it relates to your hardware. Likewise, when debugging and tuning your application, you will need to be able to interpret the results. If you don't have the skills in-house, you may want to outsource some of the work. Is your system real-time? Linux can handle many real-time activities so long as you pay attention to certain details. Will your code require regulatory approval (medical, automotive, aerospace, and so on)? The burden of regulatory verification and validation might make another OS a better choice. Even if you do choose Linux for use in these environments, it may make sense to purchase a commercially available distribution from a company that has supplied Linux for existing products, like the one you are building. Hardware Design & BGA Packages When it comes to building hardware with the Microprocessors, customers are usually encouraged to modify and reuse processor suppliers' reference designs. But depending on the complexity of your project you might have to design your own. All the variants offered by ST comes in BGA Packages. These seem to make less-experienced engineers nervous \u2014 both during layout and prototype assembly but actually, BGAs are much easier to design around than high-pin-count ultra-fine-pitch QFPs. You just have to have the right mindset. ST offers different BGA packages, but the e package must be selected by taking into account the constraints that are strongly dependent upon the application. The list below summarizes the more frequent constraints: Amount of interfaces required. Some interfaces might not be available on some packages. Some interfaces combinations might not be possible on some packages. Always refer to product datasheets for details PCB technology constraints. Small pitch and high ball density could require more PCB layers and higher PCB class requiring stack-up with micro-via (laser via) technology Package height PCB available area Thermal constraints (larger packages have better thermal dissipation capabilities) Routing and Vias When pricing a PCB, the size of the traces and vias directly affect the cost to manufacture the board. However, larger traces and vias, while cheaper, can make layout more difficult. Therefore, it is necessary to understand the optimum size of traces and vias for a given design. Trace size background information The number of traces that can pass between any two pads of a BGA footprint depends on the trace width and trace spacing. Trace width is the actual width of the trace. Trace spacing is the distance between the edges of any two adjacent traces or a trace and a pad. Trace widths and clearance are shown below. A \u201cx/y trace\u201d indicates a PCB that uses design rules with trace width of x mils and trace spacing of y mils. For example, a 5/6 trace indicates a PCB with trace width of 5mils and trace spacing of 6mils. The number of traces that can be routed between any two adjacent pads of the BGA can be calculated using the formula (formula assumes all the traces are equal width): tn tw + (tn + 1) ts <= BP \u2013 BD where, tn = number of traces tw = trace width ts = trace spacing BP = BGA pitch BD = BGA ball diameter For example, to calculate the number of 5/5 traces that can be routed between adjacent pads of a typical BGA package assuming : tw = 5mils, ts = 5mils, BP = 39.37mil (1mm) and BD = 13.78mil (0.35mm) Using all this in the above equation: 5tn + 5(tn + 1) <= 25.59 10tn <= 20.59 tn <= 2.059 traces. This result indicates that two (2) full 5/5 traces can be routed between adjacent balls of the BGA package. Via size background information There are two important parameters for vias: drill diameter and annular ring thickness. Drill diameter is the diameter of the actual drilled hole in the PCB. The annular ring thickness is the thickness of the pad that surrounds the drilled hole. To determine the diameter of the finished via, use the following formula: Finished via diameter = Drill diameter + 2 x (Annular ring thickness) A \u201cx/y via\u201d indicates a via with drill diameter of x mils and finished via diameter of y mils. For example, a 12/24 via indicates a via with drill diameter of 12mils and finished via diameter of 24mils. Package selected and design considerations In my case, I choose two very different packages offered by ST based on features. I've opted for the following rules. PCB Rule for 0.5mm pitch package for TFBGA361 Package PCB Rule for 0.65mm pitch package for Power improved pitch on TFBGA361 PCB Rule for 0.8mm pitch package for LFBGA448 Package Decoupling All the power supply and ground pins must be properly connected to the power supplies. These connections, including pads, tracks and vias should have as low impedance as possible. This is typically achieved with thick track widths and, preferably, the use of dedicated power supply planes in multilayer PCBs. In addition, each power supply pair should be decoupled with ceramic capacitors most of the time 100nF or 1\u00b5F. These capacitors need to be placed as close as possible to, or below, the appropriate pins on the underside of the PCB. Exact values might depend on the application. Grounding on PCBs The term \"Ground\" refers to the \"Earth\" UL requires (for safety reasons) the Green wire (Yellow wire, Yellow/Green wire etc.) connect from \"Chassis\" of electrical system to the \"Earth\". Reason being, if the phase wire accidentally touches the chassis of the system, then if someone walks up to the chassis and touches it, the electrical current passes through the person's heart and may kill him. So if a phase wire shorts to chassis, then we want high enough current to pass through the Grounding wire so that the Circuit breaker/ fuse can trip off. ****Safety is the only value of that wire in the electrical system and it has nothing to do with passing through EMI/EMC standards. EMI personal often incorrectly refer to the Faraday cage or Shielding surrounding a product as earth ground or chassis ground. Faraday's cage's only function is to keep the fields in the unit inside the unit and the outside fields from entering into the unit. If an electrical system or a product has a shield and a chassis, then it is recommended to connect the shield of the system to the system's chassis because, the shield is simply being the continuation of the Faraday's cage. It is not recommended to connect the shield to the product's ground. Ground on PC Boards is often considered as the region of Zero Volt potential with Zero resistance and impedance. However, this is NOT TRUE . It is only close to Zero volts but not Zero volts. It is close to true only in the case of DC because when you send energy down the transmission lines, then you get current in the ground and that current cases a voltage drop and that voltage drop means the ground potential from one point to the other is never Zero. Let's talk about Energy What is Energy? ...the property of matter that manifests itself as the capacity to perform work and it exists in many forms (mechanical, light, sound, heat, electrical etc.) Energy can neither be created or destroyed it can only be transformed from one form to the other. Light energy and electrical energy are precisely the same forms of energy. The only difference is light is a million times higher frequency than Electrical energy at 500 MHz in the signal lines. Q: Where is the energy in the circuit? Is it in the voltage or is it in the current? A: Neither. It is not in the voltage or in the current. The energy is in the fields, better know as the electric fields and magnetic fields. Q: Where is the energy located in the circuit board? Is it in the traces or is it in the planes? A: Neither. The energy doesn't travel in the copper. The energy travels in the spaces between the traces and the planes...in the dielectric. The energy in the FR-4 circuit board travels in the plastic and fibre glass material of the PC Board. No energy travels in the copper. The energy that travels between the traces and planes creates a current in the copper which intern creates voltage drop in the circuit but not the other way around. Think about it, it makes sense why Circuit A or Trace A interferes with Circuit B or Trace B or why energy is coupled from one place to the other even though the circuits are not connected to each other. This interference happens only when good care is NOT taken of the space between the trace and return paths. It is all about the space. Note: The Fields (E and H Fields) carry energy and they create voltage and current not the other way around. Energy in Wave guides. The energy in a transmission event is called a wave, an electromagnetic wave. The traces or the trace and plane that make up the transmission line steer the energy from point A to point B. These copper elements act as a wave guide. So as the trace travels through the circuit board above a plane, the energy travels between the space of the trace and the plane (the dielectric). Why does it do that? Because it is the path of lowest impedance for the energy. Of course the air has a lot lower impedance than the dielectric but there is not trace or place hanging in the air. These copper elements acts as a wave guide, whether it is a power system or signal or a digital system; every forward path and return path constitutes as a wave guide which guides energy from point A to point A transmission line or wave guide both are same, is a pair of conductors or wires used to move energy from point A to point B. Voltage across copper and current in the copper. How does a circuit work? Wrong: When you launch energy into a circuit, the current travels down the trace and into the load and comes back up the ground trace to the driver. WRONG!! Correct: The energy is launched into the circuit in the form of a wave consisting of fields. The fields create a voltage across both copper features at the same time (trace and ground) and they create a forward and return current in both the copper features at the same time. So the forward current and return current are formed at the exact same time. This is the reason why ground potential is never zero but close to zero. The current is not down and back kind of thing, it is the simultaneous thing. Stripline Wave Guide (Centred Strip Line) This is a centred stripline. When we launch energy into the stripline, the first thing that appears is the electric field, it is coupled from that trace to the planes and the energy in that field excites the electrons of the copper and electrons start to move causing current flow in the copper of planes and the copper of the trace. The reaction to that is to form a magnetic field which surrounds the trace and is sandwiched between the trace and the planes. Notice all of that energy is in that space between the trace and the planes. It also spreads a little bit to the outside, it is the spreading of the energy and that spreading of energy is what causes that cross talks and other sorts of interference if things are too close to one another. Microstrip line These are the fields of an outer layer of the transmission line. The trace routed above a ground plane and on the 1st layer of the board. You can notice the fields expand more than on the fields on the inner layers. This expansion causes some radiation from the outer surface of the boards. The fields expand more on outer layers, cross talks are more on outer layers if good care is not taken in the spacing. Let's talk about Return Path Imagine a 2 Layer Microstrip style PC Board, where a signal is routed from Driver IC to the Load and load and the driver ICs are connected to the ground plane through a via. Now when the frequency of the signal is low say just DC energy that doesn't change state is being fed say power supply is being fed, then the return path for the current would be the short and quick path cross the plane between the ground pins of the ICs. Why? Because at very low frequencies, current will take the path of least resistance, since impedance of \"L\" becomes negligible compared to \"R\" because the formula for Transmission Line impedance says \u21d2 Z = Sqrt [(R+jwL) / (G + jwC) ]) According to the formula it says impedance is the square root of Resistance + Frequency times Inductance. Now as the frequency gets low, inductance becomes low. In the case of DC frequency is 0 so inductance is 0 and hence it only depends on the resistance of the copper. The DC current wouldn't just take the short path on the PC Board, it would spread out to a very wide swath and the swath would be about as wide as it is long. So it would effectively form a square because the DC would take the path of least resistance because resistance is per square measurement, therefore the current path would be a square. Now if you could change the frequency of the output signal from the driver IC to a few KHz or MHz, then the return current path for the signal travel directly below the trace between the driver and receiver ICs. Remember the forward and return current are being generated simultaneously. The arrows in the above image indicate that. Experiment to show current / energy takes the path of least impedance. To prove the this point you can run a simple experiment in your lab. Connect a 2 meter Co-axial cable (B) and loop it back such that the ends of the co-axial cable are near one another separated by 2 inches and couple the shields of the co-axial cable together with 2 inch piece wire (D) and attach a signal generator (A) to one end and a load resistor (C) to the other end of the co-axial. Do a basic calculation on how much current the resistor can take and put a current loop around that piece of wire. Then turn on the signal generator and put it in DC mode and send energy through the co-axial. Now what you will notice is that, the return current will pass through that short piece of wire (D) and not on the co-axial shield. Now if you increase the frequency in the signal generator (A), what you will notice is that as the frequency gets higher and higher, the return current in the short piece of wire (D) connecting the shields of co-axial cable will reduce. Now after the signal frequency reaches some MHz you will notice that almost no current flows through (D). All of the return current flows through the shield of the co-axial cable (B) even though the length of the co-axial able is longer than the (D). This is because it has a lot less impedance i.e. a path of lowest impedance and greatest capacitance \u21d2 according to the impedance formula. This experiment proves that, energy always takes the path of least impedance. Impedance When the return current path is directly under the trace, we often refer to it as the \"Path of least impedance\" because energy always takes the path of lowest impedance. Impedance is essentially the path of lowest inductance and greatest capacitance coupled. What is inductance (L)? Inductance (L) is an impedance to change in current flow, caused by the (inertia) magnetic field, meaning what? Now imagine you have two traces side by side separated by some spacing , one is the forward path and the other is the return path. Now when you launch energy into this circuit, the fields exists between these space and the magnetic field is going to be of large size because of the spacing and result of its large size it will have higher inertia which means it will create high impedance for the current change in the circuit. That is what drives up inertia. Large volume of magnetic fields equals large volume of Inductance. How to reduce Inductance and increase capacitance? In other words, how to reduce impedance? Instead of having the traces far apart, bring them closer to each other. Now you will have a small volume of space for the magnetic fields and the end result is you will have small field, small emission and low inductance. The best of all, put one directly above the other meaning have the forward path and the return path directly over one an other in the board stack. Route everything above the ground plane and keep the dielectric small and you will minimise the inductance. How do you create a low inductance or low impedance in the power vias of a decoupling capacitors? You do not need large vias to create low inductance. You can achieve that by bring the vias very close to each other. You keep it at the side of the capacitor pads. If possible keep it on the pads of the capacitors. Routing Low frequency and High Frequency signals. If you were to route low frequency signals, try to route the forward and return path close to each other. Better would be directly above one another. Because low frequency signals tends to spread a lot. You need to channel it such a way that it follows a path of least resistance or impedance. That would be traces directly on top of one another. When it comes to high frequency signals, if you are not cognisant about how you route the forward and return path such that they have least impedance then the high frequency signals will self channel itself on the least impedance path meaning it might use traces adjacent to it as a return path causing cross talks. You have to route every signal with respect to the ground like you actually mean it. You cannot route them randomly and say \"Hey it will find it's ground\". It doesn't work that way. That's not how circuits work. Every signals needs to have an intentional low impedance ground nearby. Always try to reference a signal to a ground place below it. Is it okay to reference a power place for a signal as a return path? Answer: Yes, if and only if, you reference a power plane that generated the signal. Let's say the signal is generated by a 5V driver as a 5V signal. Then you could reference it with a 5V power place meaning you could come out of the driver route across the 5V power plane to the receiver. You cannot reference it with a 3.3V plane. Also make sure to the power plane has a Ground plane reference close by. But it is generally not a good idea to change layers when you do reference a power plane. Position of components Group components by Function/Family. Analog in one area, Digital in another. Devices operating at different voltages in their own respective areas. Devices operating at different frequencies in their own respective areas. All ICs routing to connectors must be placed very near to their respective connectors and try to filter out the signals going to the connector or cable because if you don't then the noise, will go to the other board or worse if it goes into the cable, the cable may act like an antenna and radiate the energy. Separate the analog and digital sections by a distance of 20 x the thickness of dielectric between the layers and do not split the ground planes. If you want to avoid coupling of noise from one section to the other, just split the power planes only and do not split ground plane and it should work. Do not route across split ground planes and split power planes. It will generate a lot of EMI problems. Try avoiding to route on the ground planes. If you have to then keep it as short as possible. Use a zero ohm resistor to cross slower signals over other signals. Do not do this with high frequency signals because a zero ohm at frequency is not a zero ohm resistor. 6 layer PC board stackups to avoid L1 - Signal L2 - Signal L3 - Ground L4 - Power L5 - Signal L6 - Signal L1 - Signal L2 - Power L3 - Signal L4 - Signal L5 - Ground L6 - Signal Best 6 layer board layer stackup L1 - Sig/power L2 - Ground L3 - Sig/Power L4 - Ground L5 - Sig/Power L6 - Ground L1 - Sig/power L2 - Ground L3 - Sig/Power L4 - Ground/Signal L5 - Ground L6 - Signal/Power DDR Routing It\u2019s worth investing a bit of time to learn about length-tuning and controlled impedances since it will give you immense design flexibility when architecting your system. When most people think of DDR routing, length-tuning is the first thing that comes to mind. If you use a decent PCB design package, setting up length-tuning rules and laying down meandered routes is so trivial to do that most designers don\u2019t think anything of it \u2014 they just go ahead and length-match everything that\u2019s relatively high-speed \u2014 SDRAM, SDIO, parallel CSI / LCD, etc. Using a proper PCB stack-up (usually a ~0.1mm prepreg will result in a close-to-50-ohm impedance for a 5mil-wide trace) is your first line of defense against impedance issues, and is usually sufficient for getting things working well enough to avoid simulation / refinement. The biggest source of EMC issues related to DDR3 is likely going to come from your address bus. DDR3 uses a one-way address bus (the CPU is always the transmitter and the memory chip is always the receiver), and DDR memory chips do not have on-chip termination for these signals. Theoretically, they should be terminated to VTT (a voltage derived from VDDQ/2) with resistors placed next to the DDR memory chip. On large fly-by buses with multiple memory chips, you\u2019ll see these VTT termination resistors next to the last chip on the bus. The resistors absorb the EM wave propagating from the MPU which reduces the reflections back along the transmission line that all the memory chips would see as voltage fluctuations. To reduce cross-talk, you can put plenty of space between traces \u2014 three times the width (3S) is a standard rule of thumb. DDR Pin Swapping Because DDR memory doesn\u2019t care about the order of the bits getting stored, you can swap individual bits \u2014 except the least-significant one if you\u2019re using write-leveling \u2014 in each byte lane with no issues. Byte lanes themselves are also completely swappable. Having said that, since all the parts I reviewed are designed to work with a single x16-wide DDR chip (which has an industry-standard pinout), I found that most pins were already balled out reasonably well. Before you start swapping pins, make sure you\u2019re not overlooking an obvious layout that the IC designers intended. DDR Routing Recommendations Pay attention to PCB stack-up. Use a 4-layer stack-up with thin prepreg (~0.1mm) to lower the impedance of your microstrips \u2014 this allows the traces to transfer more energy to the receiver. Those inner layers should be solid ground and DDR VDD planes respectively. Make sure there are no splits under the routes. If you\u2019re nit-picky, pull back the outer-layer copper fills from these tracks so you don\u2019t inadvertently create coplanar structures that will lower the impedance too much. Avoid multiple DRAM chips. If you start adding extra DRAM chips, you\u2019ll have to route your address/command signals with a fly-by topology (which requires terminating all those signals \u2014 yuck), or a T-topology (which requires additional routing complexity). Stick with 16-bit-wide SDRAM, and if you need more capacity, spend the extra money on a dual-die chip \u2014 you can get up to 2 GB of RAM in a single X16-wide dual-rank chip, which should be plenty for anything you\u2019d throw at these CPUs. Faster RAM makes routing easier. Even though our processors reviewed here rarely can go past 400-533 MHz DDR speeds, using 800 or 933 MHz DDR chips will ease your timing budget. The reduced setup/hold times make address/command length-tuning almost entirely unnecessary, and the reduced skew even helps with the bi-directional data bus signals. It is always good to read ST's application notes on DDR3 Routing. Even though you might not be applying all of their recommended rules, but you end up learning a lot of information. Power Management IC PMIC Power On Sequence PWR_ON_RESET => BUCK3 => BUCK1, BUCK4, LDO2, LDO5 => LDO4 BUCK2, LDO1, LDO3, LDO6, REFDDR enable by I2C PMIC Factory Default Voltages Buck Converters BUCK1 (VOUT1) = Default 1.2V; Imax = 2000mA; Application = Core supply. BUCK2 (VOUT2) = Default 1.1V; Imax = 1600mA; NOT ON BY DEFAULT Application = Core BUCK3 (VOUT3) = Default 1.8V; Imax = 1000mA; Application = VIO. BUCK4 (VOUT4) = Default 3.3V; Imax = 3000mA; Application = Application CPU or GP. LDOs LDO1 = Default 1.8V; Imax = 800mA; NOT ON BY DEFAULT Application = Core supply. LDO2 = Default 2.9V; Imax = 800mA; Application = Core supply. LDO3 = Default 1.8V; Imax = 150mA; NOT ON BY DEFAULT Application = Core supply. LDO4 = Fixed 3.3V ; Imax = 200mA; Application = Core supply. LDO5 = Default 2.9V; Imax = 800mA; Application = Core supply. LDO6 = Default 1.0V; Imax = 350mA; NOT ON BY DEFAULT Application = Core supply.","title":"Home"},{"location":"#logicboard-som-hardware-and-software-documentation","text":"","title":"Logicboard SoM Hardware and Software Documentation"},{"location":"#reference-design-images","text":"","title":"Reference Design Images."},{"location":"#version-100","text":"Size - 50mm x 50mm PCB 3D View PCB Layout (Top Layer) Actual PCB","title":"Version 1.0.0"},{"location":"#version-200","text":"Size - 42mm x 42mm PCB Layout (Top Layer) PCB 3D View Actual PCB V1 and V2 Size Difference","title":"Version 2.0.0"},{"location":"#target-audience","text":"This documentation is targeted at embedded engineers who want to design a system around the STM32MP15x series microprocessors. In this documentation, I've put together a broad overview of what's involved in designing a system around ST-Microelectronics STM32MP15x series microprocessors, and then a dive into some specific parts you should check out \u2014 and others you should avoid.","title":"Target Audience"},{"location":"#what-is-a-logicboard","text":"Logicboard is a System on Module (SoM) that includes ST-Microelectronics Dual Arm Cortex-A7 core operating at 800 MHz + Cortex\u00ae-M4 core running at 209 MHz, DDR3L Memory, eMMC Flash, and power circuits.","title":"What is a Logicboard?"},{"location":"#key-features-of-the-som","text":"STM32MP157 Arm\u00ae-based dual Cortex\u00ae-A7 32 bits + Cortex\u00ae-M4 32 bits MPU 4-Gbit (512MB), DDR3L, 16 bits RAM 4GB eMMC Flash Wi-Fi\u00ae (2.4GHz) and Bluetooth Low Energy 5.0 (next revision) Form factor: 42mm x 42 mm Module","title":"Key Features of the SoM"},{"location":"#key-features-of-carrier-board","text":"Gigabit Ethernet BLE 5.0 USB-C OTG USB-A Host Micro SD-Card 12V Power Supply Barrel Jack MIPI-DSI Port RGB LCD Port ST-Link Debug Boot Switch Peripherals (LEDs, Push Buttons) GPIO Expansions","title":"Key Features of Carrier Board"},{"location":"#why-am-i-doing-this","text":"I know that there are lots of people \u2014 especially hobbyists and even professional engineers who are thinking, \u201cI do all my embedded Linux development with Raspberry Pi boards and BeagleBone Black DKs \u2014 Why do I need this SoM?\u201d Yes, Raspberry Pi and Beaglebone Black SBCs, on the surface, look similar to some of these parts: they run Linux, you can attach displays to them, do networking, and they have USB, GPIO, I2C, and SPI signals available. Now if you dig a bit deep and see, Raspberry Pi's processor BCM2711 was custom-made, from the ground up, to go into smart TVs and set-top boxes \u2014 it\u2019s not a general-purpose embedded Linux application processor. This processor has video decoding and graphics acceleration, built-in HDMI transmitters that can drive dual 4k displays but just two PWM channels and not even a single ADC input. Plus you cannot run real-time tasks on this board and this beast consumes a lot of power. So it isn\u2019t generally suited for embedded Linux work. They are primarily designed to make commuting accessible to everyone. Of course, there are workarounds \u2014 like I2C-interfaced PWM chips, SPI-interfaced ADCs, or LCD modules with HDMI receivers \u2014 but they involve external hardware that adds power, bulk, and cost. If you\u2019re building a quantity-of-one project and you don\u2019t care about these things, then maybe the Pi is the right choice for the job, but if you\u2019re prototyping a real product that\u2019s going to go into production someday, you\u2019ll want to look at the entire landscape before deciding what\u2019s best. Some parts of the aforementioned shortcomings hold true for Beaglebone Black also. Although this SBC is ideal for embedded Linux work, you cannot run Real-time applications in them (Okay! you can, but it is quite difficult). And when it comes to production, you've got to design your product from scratch which increases, time to market, project costs, development risks etc. I believe this will be a risky investment for entrepreneurs willing to put everything on the line. On top of everything I mentioned, HDMI is of no use to an embedded Linux developer, as all LCDs use parallel RGB, LVDS, or MIPI as interfaces.","title":"Why am I doing this?"},{"location":"#lets-get-started","text":"When you pick a Microcontroller, you should pick the right part for the job and not be afraid to learn whole new software ecosystems. Now, the best part of working with Microprocessors is that once you\u2019re booted into Linux on basically any Microprocessors, they become identical development environments. As long as your processor checks off the right boxes, your application code won\u2019t know if it\u2019s running on an ST or a Microchip part \u2014 even if one of those is a brand-new dual-core Cortex-A7 and the other is an old ARM9. Your I2C drivers, your GPIO calls \u2014 even your V4L-based image processing code \u2014 will all work seamlessly. At least, that\u2019s the sales pitch. Getting a Microprocessor booted is a completely separate experience, and that's what we'll be concentrating on. For now, I\u2019m focusing heavily on hardware design. These chips vary considerably in PCB Design difficulty when compared to a traditional Microcontroller. I intentionally designed these boards from scratch rather than starting with the Manufacturer's CAD files. This approach helped me to understand the little intricacies of the MPU, as well as optimize the design for cost and hand-assembly. Later in this documentation, I'll include some pictures of the boards and screenshots of the layouts to illustrate some points. Before we begin, let's take a quick detour and study some basics.","title":"Let's get started"},{"location":"#microcontroller-vs-microprocessor","text":"The first thing you'll notice if you're coming from microcontrollers is that Linux doesn't normally work on Cortex-M, 8051, AVR, or other popular microcontroller architectures. Rather, we use application processors, such as the Arm Cortex-A, MIPS, and other variants. The most notable difference between these application processors and microcontrollers is that microprocessors include a memory management unit (MMU), whereas microcontrollers do not. Although you can run Linux without an MMU, but it's not recommended. Aside from the MMU, the distinction between MCUs and MPUs is becoming increasingly blurry. Modern application processors share many of the same peripherals as microcontrollers, and high-end Cortex-M7 microcontrollers offer clock speeds that are comparable to entry-level application processors.","title":"Microcontroller vs Microprocessor"},{"location":"#choosing-linux","text":"Why is Linux so pervasive? And why does something as simple as a TV need to run something as complex as Linux just to display streaming video on a screen? The simple answer is Your TV is not simply displaying a video stream as the old analog sets used to do. The stream is digital, possibly encrypted, and it needs processing to create an image. Your TV is connected to the internet. It can receive content from smartphones, tablets, and home media servers. It can be (or soon will be) used to play games and so on. You need a full operating system to manage this degree of complexity. Here are some points that drive the adoption of Linux: Linux has the necessary functionality. It has a good scheduler, a good network stack, support for USB, Wi-Fi, Bluetooth, many kinds of storage media, good support for multimedia devices, and so on. It ticks all the boxes. Linux has been ported to a wide range of processor architectures, including some that are very commonly found in SoC designs \u2013 Arm, MIPS, x86, and PowerPC. Linux is open source, so you have the freedom to get the source code and modify it to meet your needs. You, or someone working on your behalf, can create a board support package for your particular SoC board or device. You can add protocols, features, and technologies that may be missing from the mainline source code. You can remove features that you don't need to reduce memory and storage requirements. Linux is flexible. Linux has an active community; in the case of the Linux kernel, very active. There is a new release of the kernel every 8 to 10 weeks, and each release contains code from more than 1,000 developers. An active community means that Linux is up to date and supports current hardware, protocols, and standards. Open source licenses guarantee that you have access to the source code. There is no vendor tie-in. For these reasons, Linux is an ideal choice for complex devices.","title":"Choosing Linux"},{"location":"#when-not-to-choose-linux","text":"Is Linux suitable for your project? Linux works well where the problem being solved justifies the complexity. It is especially good where connectivity, robustness, and complex user interfaces are required. However, it cannot solve every problem, so here are some things to consider before you jump in: Is your hardware up to the job? Compared to a traditional real-time operating system (RTOS) such as VxWorks or QNX, Linux requires a lot more resources. It needs at least a 32-bit processor and lots more memory. I will go into more detail in the section on typical hardware requirements. Do you have the right skill set? The early parts of a project, board bring-up, require detailed knowledge of Linux and how it relates to your hardware. Likewise, when debugging and tuning your application, you will need to be able to interpret the results. If you don't have the skills in-house, you may want to outsource some of the work. Is your system real-time? Linux can handle many real-time activities so long as you pay attention to certain details. Will your code require regulatory approval (medical, automotive, aerospace, and so on)? The burden of regulatory verification and validation might make another OS a better choice. Even if you do choose Linux for use in these environments, it may make sense to purchase a commercially available distribution from a company that has supplied Linux for existing products, like the one you are building.","title":"When not to choose Linux"},{"location":"#hardware-design-bga-packages","text":"When it comes to building hardware with the Microprocessors, customers are usually encouraged to modify and reuse processor suppliers' reference designs. But depending on the complexity of your project you might have to design your own. All the variants offered by ST comes in BGA Packages. These seem to make less-experienced engineers nervous \u2014 both during layout and prototype assembly but actually, BGAs are much easier to design around than high-pin-count ultra-fine-pitch QFPs. You just have to have the right mindset. ST offers different BGA packages, but the e package must be selected by taking into account the constraints that are strongly dependent upon the application. The list below summarizes the more frequent constraints: Amount of interfaces required. Some interfaces might not be available on some packages. Some interfaces combinations might not be possible on some packages. Always refer to product datasheets for details PCB technology constraints. Small pitch and high ball density could require more PCB layers and higher PCB class requiring stack-up with micro-via (laser via) technology Package height PCB available area Thermal constraints (larger packages have better thermal dissipation capabilities)","title":"Hardware Design &amp; BGA Packages"},{"location":"#routing-and-vias","text":"When pricing a PCB, the size of the traces and vias directly affect the cost to manufacture the board. However, larger traces and vias, while cheaper, can make layout more difficult. Therefore, it is necessary to understand the optimum size of traces and vias for a given design.","title":"Routing and Vias"},{"location":"#trace-size-background-information","text":"The number of traces that can pass between any two pads of a BGA footprint depends on the trace width and trace spacing. Trace width is the actual width of the trace. Trace spacing is the distance between the edges of any two adjacent traces or a trace and a pad. Trace widths and clearance are shown below. A \u201cx/y trace\u201d indicates a PCB that uses design rules with trace width of x mils and trace spacing of y mils. For example, a 5/6 trace indicates a PCB with trace width of 5mils and trace spacing of 6mils. The number of traces that can be routed between any two adjacent pads of the BGA can be calculated using the formula (formula assumes all the traces are equal width): tn tw + (tn + 1) ts <= BP \u2013 BD where, tn = number of traces tw = trace width ts = trace spacing BP = BGA pitch BD = BGA ball diameter For example, to calculate the number of 5/5 traces that can be routed between adjacent pads of a typical BGA package assuming : tw = 5mils, ts = 5mils, BP = 39.37mil (1mm) and BD = 13.78mil (0.35mm) Using all this in the above equation: 5tn + 5(tn + 1) <= 25.59 10tn <= 20.59 tn <= 2.059 traces. This result indicates that two (2) full 5/5 traces can be routed between adjacent balls of the BGA package.","title":"Trace size background information"},{"location":"#via-size-background-information","text":"There are two important parameters for vias: drill diameter and annular ring thickness. Drill diameter is the diameter of the actual drilled hole in the PCB. The annular ring thickness is the thickness of the pad that surrounds the drilled hole. To determine the diameter of the finished via, use the following formula: Finished via diameter = Drill diameter + 2 x (Annular ring thickness) A \u201cx/y via\u201d indicates a via with drill diameter of x mils and finished via diameter of y mils. For example, a 12/24 via indicates a via with drill diameter of 12mils and finished via diameter of 24mils.","title":"Via size background information"},{"location":"#package-selected-and-design-considerations","text":"In my case, I choose two very different packages offered by ST based on features. I've opted for the following rules. PCB Rule for 0.5mm pitch package for TFBGA361 Package PCB Rule for 0.65mm pitch package for Power improved pitch on TFBGA361 PCB Rule for 0.8mm pitch package for LFBGA448 Package","title":"Package selected and design considerations"},{"location":"#decoupling","text":"All the power supply and ground pins must be properly connected to the power supplies. These connections, including pads, tracks and vias should have as low impedance as possible. This is typically achieved with thick track widths and, preferably, the use of dedicated power supply planes in multilayer PCBs. In addition, each power supply pair should be decoupled with ceramic capacitors most of the time 100nF or 1\u00b5F. These capacitors need to be placed as close as possible to, or below, the appropriate pins on the underside of the PCB. Exact values might depend on the application.","title":"Decoupling"},{"location":"#grounding-on-pcbs","text":"The term \"Ground\" refers to the \"Earth\" UL requires (for safety reasons) the Green wire (Yellow wire, Yellow/Green wire etc.) connect from \"Chassis\" of electrical system to the \"Earth\". Reason being, if the phase wire accidentally touches the chassis of the system, then if someone walks up to the chassis and touches it, the electrical current passes through the person's heart and may kill him. So if a phase wire shorts to chassis, then we want high enough current to pass through the Grounding wire so that the Circuit breaker/ fuse can trip off. ****Safety is the only value of that wire in the electrical system and it has nothing to do with passing through EMI/EMC standards. EMI personal often incorrectly refer to the Faraday cage or Shielding surrounding a product as earth ground or chassis ground. Faraday's cage's only function is to keep the fields in the unit inside the unit and the outside fields from entering into the unit. If an electrical system or a product has a shield and a chassis, then it is recommended to connect the shield of the system to the system's chassis because, the shield is simply being the continuation of the Faraday's cage. It is not recommended to connect the shield to the product's ground. Ground on PC Boards is often considered as the region of Zero Volt potential with Zero resistance and impedance. However, this is NOT TRUE . It is only close to Zero volts but not Zero volts. It is close to true only in the case of DC because when you send energy down the transmission lines, then you get current in the ground and that current cases a voltage drop and that voltage drop means the ground potential from one point to the other is never Zero.","title":"Grounding on PCBs"},{"location":"#lets-talk-about-energy","text":"What is Energy? ...the property of matter that manifests itself as the capacity to perform work and it exists in many forms (mechanical, light, sound, heat, electrical etc.) Energy can neither be created or destroyed it can only be transformed from one form to the other. Light energy and electrical energy are precisely the same forms of energy. The only difference is light is a million times higher frequency than Electrical energy at 500 MHz in the signal lines. Q: Where is the energy in the circuit? Is it in the voltage or is it in the current? A: Neither. It is not in the voltage or in the current. The energy is in the fields, better know as the electric fields and magnetic fields. Q: Where is the energy located in the circuit board? Is it in the traces or is it in the planes? A: Neither. The energy doesn't travel in the copper. The energy travels in the spaces between the traces and the planes...in the dielectric. The energy in the FR-4 circuit board travels in the plastic and fibre glass material of the PC Board. No energy travels in the copper. The energy that travels between the traces and planes creates a current in the copper which intern creates voltage drop in the circuit but not the other way around. Think about it, it makes sense why Circuit A or Trace A interferes with Circuit B or Trace B or why energy is coupled from one place to the other even though the circuits are not connected to each other. This interference happens only when good care is NOT taken of the space between the trace and return paths. It is all about the space. Note: The Fields (E and H Fields) carry energy and they create voltage and current not the other way around.","title":"Let's talk about Energy"},{"location":"#energy-in-wave-guides","text":"The energy in a transmission event is called a wave, an electromagnetic wave. The traces or the trace and plane that make up the transmission line steer the energy from point A to point B. These copper elements act as a wave guide. So as the trace travels through the circuit board above a plane, the energy travels between the space of the trace and the plane (the dielectric). Why does it do that? Because it is the path of lowest impedance for the energy. Of course the air has a lot lower impedance than the dielectric but there is not trace or place hanging in the air. These copper elements acts as a wave guide, whether it is a power system or signal or a digital system; every forward path and return path constitutes as a wave guide which guides energy from point A to point A transmission line or wave guide both are same, is a pair of conductors or wires used to move energy from point A to point B. Voltage across copper and current in the copper. How does a circuit work? Wrong: When you launch energy into a circuit, the current travels down the trace and into the load and comes back up the ground trace to the driver. WRONG!! Correct: The energy is launched into the circuit in the form of a wave consisting of fields. The fields create a voltage across both copper features at the same time (trace and ground) and they create a forward and return current in both the copper features at the same time. So the forward current and return current are formed at the exact same time. This is the reason why ground potential is never zero but close to zero. The current is not down and back kind of thing, it is the simultaneous thing. Stripline Wave Guide (Centred Strip Line) This is a centred stripline. When we launch energy into the stripline, the first thing that appears is the electric field, it is coupled from that trace to the planes and the energy in that field excites the electrons of the copper and electrons start to move causing current flow in the copper of planes and the copper of the trace. The reaction to that is to form a magnetic field which surrounds the trace and is sandwiched between the trace and the planes. Notice all of that energy is in that space between the trace and the planes. It also spreads a little bit to the outside, it is the spreading of the energy and that spreading of energy is what causes that cross talks and other sorts of interference if things are too close to one another.","title":"Energy in Wave guides."},{"location":"#microstrip-line","text":"These are the fields of an outer layer of the transmission line. The trace routed above a ground plane and on the 1st layer of the board. You can notice the fields expand more than on the fields on the inner layers. This expansion causes some radiation from the outer surface of the boards. The fields expand more on outer layers, cross talks are more on outer layers if good care is not taken in the spacing.","title":"Microstrip line"},{"location":"#lets-talk-about-return-path","text":"Imagine a 2 Layer Microstrip style PC Board, where a signal is routed from Driver IC to the Load and load and the driver ICs are connected to the ground plane through a via. Now when the frequency of the signal is low say just DC energy that doesn't change state is being fed say power supply is being fed, then the return path for the current would be the short and quick path cross the plane between the ground pins of the ICs. Why? Because at very low frequencies, current will take the path of least resistance, since impedance of \"L\" becomes negligible compared to \"R\" because the formula for Transmission Line impedance says \u21d2 Z = Sqrt [(R+jwL) / (G + jwC) ]) According to the formula it says impedance is the square root of Resistance + Frequency times Inductance. Now as the frequency gets low, inductance becomes low. In the case of DC frequency is 0 so inductance is 0 and hence it only depends on the resistance of the copper. The DC current wouldn't just take the short path on the PC Board, it would spread out to a very wide swath and the swath would be about as wide as it is long. So it would effectively form a square because the DC would take the path of least resistance because resistance is per square measurement, therefore the current path would be a square. Now if you could change the frequency of the output signal from the driver IC to a few KHz or MHz, then the return current path for the signal travel directly below the trace between the driver and receiver ICs. Remember the forward and return current are being generated simultaneously. The arrows in the above image indicate that. Experiment to show current / energy takes the path of least impedance. To prove the this point you can run a simple experiment in your lab. Connect a 2 meter Co-axial cable (B) and loop it back such that the ends of the co-axial cable are near one another separated by 2 inches and couple the shields of the co-axial cable together with 2 inch piece wire (D) and attach a signal generator (A) to one end and a load resistor (C) to the other end of the co-axial. Do a basic calculation on how much current the resistor can take and put a current loop around that piece of wire. Then turn on the signal generator and put it in DC mode and send energy through the co-axial. Now what you will notice is that, the return current will pass through that short piece of wire (D) and not on the co-axial shield. Now if you increase the frequency in the signal generator (A), what you will notice is that as the frequency gets higher and higher, the return current in the short piece of wire (D) connecting the shields of co-axial cable will reduce. Now after the signal frequency reaches some MHz you will notice that almost no current flows through (D). All of the return current flows through the shield of the co-axial cable (B) even though the length of the co-axial able is longer than the (D). This is because it has a lot less impedance i.e. a path of lowest impedance and greatest capacitance \u21d2 according to the impedance formula. This experiment proves that, energy always takes the path of least impedance. Impedance When the return current path is directly under the trace, we often refer to it as the \"Path of least impedance\" because energy always takes the path of lowest impedance. Impedance is essentially the path of lowest inductance and greatest capacitance coupled. What is inductance (L)? Inductance (L) is an impedance to change in current flow, caused by the (inertia) magnetic field, meaning what? Now imagine you have two traces side by side separated by some spacing , one is the forward path and the other is the return path. Now when you launch energy into this circuit, the fields exists between these space and the magnetic field is going to be of large size because of the spacing and result of its large size it will have higher inertia which means it will create high impedance for the current change in the circuit. That is what drives up inertia. Large volume of magnetic fields equals large volume of Inductance. How to reduce Inductance and increase capacitance? In other words, how to reduce impedance? Instead of having the traces far apart, bring them closer to each other. Now you will have a small volume of space for the magnetic fields and the end result is you will have small field, small emission and low inductance. The best of all, put one directly above the other meaning have the forward path and the return path directly over one an other in the board stack. Route everything above the ground plane and keep the dielectric small and you will minimise the inductance. How do you create a low inductance or low impedance in the power vias of a decoupling capacitors? You do not need large vias to create low inductance. You can achieve that by bring the vias very close to each other. You keep it at the side of the capacitor pads. If possible keep it on the pads of the capacitors. Routing Low frequency and High Frequency signals. If you were to route low frequency signals, try to route the forward and return path close to each other. Better would be directly above one another. Because low frequency signals tends to spread a lot. You need to channel it such a way that it follows a path of least resistance or impedance. That would be traces directly on top of one another. When it comes to high frequency signals, if you are not cognisant about how you route the forward and return path such that they have least impedance then the high frequency signals will self channel itself on the least impedance path meaning it might use traces adjacent to it as a return path causing cross talks. You have to route every signal with respect to the ground like you actually mean it. You cannot route them randomly and say \"Hey it will find it's ground\". It doesn't work that way. That's not how circuits work. Every signals needs to have an intentional low impedance ground nearby. Always try to reference a signal to a ground place below it. Is it okay to reference a power place for a signal as a return path? Answer: Yes, if and only if, you reference a power plane that generated the signal. Let's say the signal is generated by a 5V driver as a 5V signal. Then you could reference it with a 5V power place meaning you could come out of the driver route across the 5V power plane to the receiver. You cannot reference it with a 3.3V plane. Also make sure to the power plane has a Ground plane reference close by. But it is generally not a good idea to change layers when you do reference a power plane.","title":"Let's talk about Return Path"},{"location":"#position-of-components","text":"Group components by Function/Family. Analog in one area, Digital in another. Devices operating at different voltages in their own respective areas. Devices operating at different frequencies in their own respective areas. All ICs routing to connectors must be placed very near to their respective connectors and try to filter out the signals going to the connector or cable because if you don't then the noise, will go to the other board or worse if it goes into the cable, the cable may act like an antenna and radiate the energy. Separate the analog and digital sections by a distance of 20 x the thickness of dielectric between the layers and do not split the ground planes. If you want to avoid coupling of noise from one section to the other, just split the power planes only and do not split ground plane and it should work. Do not route across split ground planes and split power planes. It will generate a lot of EMI problems. Try avoiding to route on the ground planes. If you have to then keep it as short as possible. Use a zero ohm resistor to cross slower signals over other signals. Do not do this with high frequency signals because a zero ohm at frequency is not a zero ohm resistor.","title":"Position of components"},{"location":"#6-layer-pc-board-stackups-to-avoid","text":"L1 - Signal L2 - Signal L3 - Ground L4 - Power L5 - Signal L6 - Signal L1 - Signal L2 - Power L3 - Signal L4 - Signal L5 - Ground L6 - Signal","title":" 6 layer PC board stackups to avoid "},{"location":"#best-6-layer-board-layer-stackup","text":"L1 - Sig/power L2 - Ground L3 - Sig/Power L4 - Ground L5 - Sig/Power L6 - Ground L1 - Sig/power L2 - Ground L3 - Sig/Power L4 - Ground/Signal L5 - Ground L6 - Signal/Power","title":" Best 6 layer board layer stackup "},{"location":"#ddr-routing","text":"It\u2019s worth investing a bit of time to learn about length-tuning and controlled impedances since it will give you immense design flexibility when architecting your system. When most people think of DDR routing, length-tuning is the first thing that comes to mind. If you use a decent PCB design package, setting up length-tuning rules and laying down meandered routes is so trivial to do that most designers don\u2019t think anything of it \u2014 they just go ahead and length-match everything that\u2019s relatively high-speed \u2014 SDRAM, SDIO, parallel CSI / LCD, etc. Using a proper PCB stack-up (usually a ~0.1mm prepreg will result in a close-to-50-ohm impedance for a 5mil-wide trace) is your first line of defense against impedance issues, and is usually sufficient for getting things working well enough to avoid simulation / refinement. The biggest source of EMC issues related to DDR3 is likely going to come from your address bus. DDR3 uses a one-way address bus (the CPU is always the transmitter and the memory chip is always the receiver), and DDR memory chips do not have on-chip termination for these signals. Theoretically, they should be terminated to VTT (a voltage derived from VDDQ/2) with resistors placed next to the DDR memory chip. On large fly-by buses with multiple memory chips, you\u2019ll see these VTT termination resistors next to the last chip on the bus. The resistors absorb the EM wave propagating from the MPU which reduces the reflections back along the transmission line that all the memory chips would see as voltage fluctuations. To reduce cross-talk, you can put plenty of space between traces \u2014 three times the width (3S) is a standard rule of thumb.","title":"DDR Routing"},{"location":"#ddr-pin-swapping","text":"Because DDR memory doesn\u2019t care about the order of the bits getting stored, you can swap individual bits \u2014 except the least-significant one if you\u2019re using write-leveling \u2014 in each byte lane with no issues. Byte lanes themselves are also completely swappable. Having said that, since all the parts I reviewed are designed to work with a single x16-wide DDR chip (which has an industry-standard pinout), I found that most pins were already balled out reasonably well. Before you start swapping pins, make sure you\u2019re not overlooking an obvious layout that the IC designers intended.","title":"DDR Pin Swapping"},{"location":"#ddr-routing-recommendations","text":"Pay attention to PCB stack-up. Use a 4-layer stack-up with thin prepreg (~0.1mm) to lower the impedance of your microstrips \u2014 this allows the traces to transfer more energy to the receiver. Those inner layers should be solid ground and DDR VDD planes respectively. Make sure there are no splits under the routes. If you\u2019re nit-picky, pull back the outer-layer copper fills from these tracks so you don\u2019t inadvertently create coplanar structures that will lower the impedance too much. Avoid multiple DRAM chips. If you start adding extra DRAM chips, you\u2019ll have to route your address/command signals with a fly-by topology (which requires terminating all those signals \u2014 yuck), or a T-topology (which requires additional routing complexity). Stick with 16-bit-wide SDRAM, and if you need more capacity, spend the extra money on a dual-die chip \u2014 you can get up to 2 GB of RAM in a single X16-wide dual-rank chip, which should be plenty for anything you\u2019d throw at these CPUs. Faster RAM makes routing easier. Even though our processors reviewed here rarely can go past 400-533 MHz DDR speeds, using 800 or 933 MHz DDR chips will ease your timing budget. The reduced setup/hold times make address/command length-tuning almost entirely unnecessary, and the reduced skew even helps with the bi-directional data bus signals. It is always good to read ST's application notes on DDR3 Routing. Even though you might not be applying all of their recommended rules, but you end up learning a lot of information.","title":"DDR Routing Recommendations"},{"location":"#power-management-ic","text":"PMIC Power On Sequence PWR_ON_RESET => BUCK3 => BUCK1, BUCK4, LDO2, LDO5 => LDO4 BUCK2, LDO1, LDO3, LDO6, REFDDR enable by I2C","title":"Power Management IC"},{"location":"#pmic-factory-default-voltages","text":"Buck Converters BUCK1 (VOUT1) = Default 1.2V; Imax = 2000mA; Application = Core supply. BUCK2 (VOUT2) = Default 1.1V; Imax = 1600mA; NOT ON BY DEFAULT Application = Core BUCK3 (VOUT3) = Default 1.8V; Imax = 1000mA; Application = VIO. BUCK4 (VOUT4) = Default 3.3V; Imax = 3000mA; Application = Application CPU or GP. LDOs LDO1 = Default 1.8V; Imax = 800mA; NOT ON BY DEFAULT Application = Core supply. LDO2 = Default 2.9V; Imax = 800mA; Application = Core supply. LDO3 = Default 1.8V; Imax = 150mA; NOT ON BY DEFAULT Application = Core supply. LDO4 = Fixed 3.3V ; Imax = 200mA; Application = Core supply. LDO5 = Default 2.9V; Imax = 800mA; Application = Core supply. LDO6 = Default 1.0V; Imax = 350mA; NOT ON BY DEFAULT Application = Core supply.","title":"PMIC Factory Default Voltages"},{"location":"reference/","text":"Key Components MNP MPU: STM32MP157CAC3 / STM32MP157CAA3 DDR3L: AS4C256M16D3LC-12BCN eMMC: S40FC004C1B2C00000 PMIC: STPMIC1BPQR Wireless: LBEE59B1LV-278 / WF200SDR Reference Docs / Files Datasheets STM32MP157C/F Datasheet DDR3L RAM Datasheet eMMC Datasheet PMIC Datasheet WF200SDR Datasheet Reference Manual STM32MP157 Reference Manual Application Notes / Guides STM32MP157 hardware development Application note (AN5031) DDR memory routing guidelines Application note (AN5122) HDI PCB Design Guide STM32MP157C-DK2 Reference Files (MB1272C) MB1272C User Manual MB1272C Schematic MB1272C BOM (.xlsx format) MB1272C Altium Design Files MB1272C Fabrication Files STM32MP157A-EV1 Reference Files (MB1263) MB1263A User Manual MB1263A Schematic MB1263A BOM (.xlsx format) MB1263A Altium Design Files MB1263A Fabrication Files DSI-LCD Reference Files (MB1407C) MB1407C Schematic MB1407C BOM (.xlsx format) MB1407C Altium Design Files MB1407C Fabrication Files Logicboard Files Rev 1.0.0 Schematic Logicboard Rev 1.0.0 Schematic (PDF) PCB Fabrication Files Logicboard PCB Fabrication Files (ZIP) Bill of Materials Logicboard Bill of Materials (PDF) Logicboard Bill of Materials (.XLSX) Assembly Files Logicboard Front Assembly (PDF) Logicboard Back Assembly (PDF) 3D Files Logicboard 3D File (STEP) Logicboard Files Rev 2.0.0 Schematic Logicboard Rev 2.0.0 Schematic (PDF) PCB Fabrication Files Logicboard Rev 2.0.0 PCB Fabrication Files (ZIP) Bill of Materials Logicboard Rev 2.0.0 Bill of Materials (.XLSX) Assembly Files Logicboard Rev 2.0.0 Assembly (PDF) 3D Files Logicboard 3D File (STEP)","title":"Reference Docs"},{"location":"reference/#key-components-mnp","text":"MPU: STM32MP157CAC3 / STM32MP157CAA3 DDR3L: AS4C256M16D3LC-12BCN eMMC: S40FC004C1B2C00000 PMIC: STPMIC1BPQR Wireless: LBEE59B1LV-278 / WF200SDR","title":"Key Components MNP"},{"location":"reference/#reference-docs-files","text":"","title":"Reference Docs / Files"},{"location":"reference/#datasheets","text":"STM32MP157C/F Datasheet DDR3L RAM Datasheet eMMC Datasheet PMIC Datasheet WF200SDR Datasheet","title":"Datasheets"},{"location":"reference/#reference-manual","text":"STM32MP157 Reference Manual","title":"Reference Manual"},{"location":"reference/#application-notes-guides","text":"STM32MP157 hardware development Application note (AN5031) DDR memory routing guidelines Application note (AN5122) HDI PCB Design Guide","title":"Application Notes / Guides"},{"location":"reference/#stm32mp157c-dk2-reference-files-mb1272c","text":"MB1272C User Manual MB1272C Schematic MB1272C BOM (.xlsx format) MB1272C Altium Design Files MB1272C Fabrication Files","title":"STM32MP157C-DK2 Reference Files (MB1272C)"},{"location":"reference/#stm32mp157a-ev1-reference-files-mb1263","text":"MB1263A User Manual MB1263A Schematic MB1263A BOM (.xlsx format) MB1263A Altium Design Files MB1263A Fabrication Files","title":"STM32MP157A-EV1 Reference Files (MB1263)"},{"location":"reference/#dsi-lcd-reference-files-mb1407c","text":"MB1407C Schematic MB1407C BOM (.xlsx format) MB1407C Altium Design Files MB1407C Fabrication Files","title":"DSI-LCD Reference Files (MB1407C)"},{"location":"reference/#logicboard-files-rev-100","text":"","title":"Logicboard Files Rev 1.0.0"},{"location":"reference/#schematic","text":"Logicboard Rev 1.0.0 Schematic (PDF)","title":"Schematic"},{"location":"reference/#pcb-fabrication-files","text":"Logicboard PCB Fabrication Files (ZIP)","title":"PCB Fabrication Files"},{"location":"reference/#bill-of-materials","text":"Logicboard Bill of Materials (PDF) Logicboard Bill of Materials (.XLSX)","title":"Bill of Materials"},{"location":"reference/#assembly-files","text":"Logicboard Front Assembly (PDF) Logicboard Back Assembly (PDF)","title":"Assembly Files"},{"location":"reference/#3d-files","text":"Logicboard 3D File (STEP)","title":"3D Files"},{"location":"reference/#logicboard-files-rev-200","text":"","title":"Logicboard Files Rev 2.0.0"},{"location":"reference/#schematic_1","text":"Logicboard Rev 2.0.0 Schematic (PDF)","title":"Schematic"},{"location":"reference/#pcb-fabrication-files_1","text":"Logicboard Rev 2.0.0 PCB Fabrication Files (ZIP)","title":"PCB Fabrication Files"},{"location":"reference/#bill-of-materials_1","text":"Logicboard Rev 2.0.0 Bill of Materials (.XLSX)","title":"Bill of Materials"},{"location":"reference/#assembly-files_1","text":"Logicboard Rev 2.0.0 Assembly (PDF)","title":"Assembly Files"},{"location":"reference/#3d-files_1","text":"Logicboard 3D File (STEP)","title":"3D Files"},{"location":"software/","text":"Software Documentation Some useful Linux Commands Did you know that there are literally hundreds of Linux commands? Even on a bare-bones Linux server install there are easily over 1,000 different commands. The interesting thing is that most people only need to use a very small subset of those commands. I have listed down some commands that are used often with Logicboard 1. I'll add more commands as I find them to be used very often. System Information System info $ uname -a Kernel release info $ uname -r System host name $ hostname -I Who you are logged in as $ whoami Hardware Information kernel messages $ dmesg CPU information $ cat /proc/cpuinfo Memory information $ cat /proc/meminfo USB devices info $ lsusb Connected hardware info $ lsblk File and Directory Commands List files $ ls -al Present working directory $ pwd New directory $ mkdir Go to previous directory $ cd .. Home directory $ cd Remove (delete) a file $ rm file_name Remove directory $ rm -r directory_name Copy file $ cp <source_file_location> <destination_file_location> Copy directory $ cp -r <source_dir_location> <destination_dir_location> Rename or Move file $ mv file1 file2 Create an empty file $ touch file_name View contents of a file $ cat file_name File Permissions PERMISSION TYPE COMMAND U G W rwx rwx rwx chmod 777 filename rwx rwx r-x chmod 775 filename rwx r-x r-x chmod 755 filename rw- rw- r-- chmod 664 filename rw- r-- r-- chmod 644 filename LEGEND U = User G = Group W = World r = Read w = write x = execute - = no access Networking Network interfaces and IP address $ ip a eth0 address and details $ ip addr show dev eth0 Internet connection test $ ping www.google.com Network address of the host $ hostname -i Local IP addresses of host $ hostname -I Download $ wget http://domain.com/file Archives (TAR FILES) Create tar named archive.tar for the directory directory_name: $ tar cf archive.tar directory_name Extract the contents from archive.tar: $ tar xf archive.tar Create a gzip compressed tar file name archive.tar.gz: $ tar czf archive.tar.gz directory_name Extract a gzip compressed tar file: $ tar xzf archive.tar.gz Create a tar file with bzip2 compression: $ tar cjf archive.tar.bz2 directory_name Extract a bzip2 compressed tar file: $ tar xjf archive.tar.bz2 Extract xz file: $ tar -xf directory_name.tar.xz Installing Packages Install package.rpm $ rpm -i package.rpm Install software from source code $ tar zxvf sourcecode.tar.gz $ cd sourcecode $ ./configure $ make $ make install SSH Logins Connect to host as user $ ssh user@host Connect to host using port $ ssh -p port user@host File Transfers Secure copy $ scp file.txt user@<server_ip_addr>:/usr/local Copy files from server to local machine $ scp user@<server_ip_addr>:/usr/local/*.txt /tmp Copy directories from server $ scp -r user@<server_ip_addr>:/usr/local/*.txt /tmp Synchronize $ rsync -a /home /backups/ Sync files/directories between local and remote system $ rsync -avz /home user@<server_ip_addr>:/backups/ Tmux Commands Start tmux $ tmux Create a pane to the side Ctrl+b+% (% for horizontal panes) Ctrl+b+\" ( \" for vertical panes) Navigate between panes Ctrl+b+arrows Exit a pane $ exit Kill all sessions $ tmux kill-server New tmux window Ctrl+b+c (bottom bar displays new window number, * indicates active window) Switch between windows Ctrl+b+window_number \u21d2 Ctrl+b+1 or Ctrl+b+0 Rename a window Ctrl+b+, \u21d2 type name and hit Enter Detach a session Ctrl+d View sessions running in background $ tmux ls Attach a session to tmux $ tmux attach -t <name_of_window> example: tmux attach -t 0 Rename a session $ tmux rename-session -t <old_name> <new_name> example: tmux rename-session -t 0 git Create a new session with name $ tmux new -s docker Kill a particular session $ tmux kill-session -t <name_of_session> example: `tmux kill-session -t docker Resize active pane border Hold Ctrl+b+arrow","title":"Software"},{"location":"software/#software-documentation","text":"","title":"Software Documentation"},{"location":"software/#some-useful-linux-commands","text":"Did you know that there are literally hundreds of Linux commands? Even on a bare-bones Linux server install there are easily over 1,000 different commands. The interesting thing is that most people only need to use a very small subset of those commands. I have listed down some commands that are used often with Logicboard 1. I'll add more commands as I find them to be used very often.","title":"Some useful Linux Commands"},{"location":"software/#system-information","text":"","title":"System Information"},{"location":"software/#system-info","text":"$ uname -a","title":"System info"},{"location":"software/#kernel-release-info","text":"$ uname -r","title":"Kernel release info"},{"location":"software/#system-host-name","text":"$ hostname -I","title":"System host name"},{"location":"software/#who-you-are-logged-in-as","text":"$ whoami","title":"Who you are logged in as"},{"location":"software/#hardware-information","text":"","title":"Hardware Information"},{"location":"software/#kernel-messages","text":"$ dmesg","title":"kernel messages"},{"location":"software/#cpu-information","text":"$ cat /proc/cpuinfo","title":"CPU information"},{"location":"software/#memory-information","text":"$ cat /proc/meminfo","title":"Memory information"},{"location":"software/#usb-devices-info","text":"$ lsusb","title":"USB devices info"},{"location":"software/#connected-hardware-info","text":"$ lsblk","title":"Connected hardware info"},{"location":"software/#file-and-directory-commands","text":"","title":"File and Directory Commands"},{"location":"software/#list-files","text":"$ ls -al","title":"List files"},{"location":"software/#present-working-directory","text":"$ pwd","title":"Present working directory"},{"location":"software/#new-directory","text":"$ mkdir","title":"New directory"},{"location":"software/#go-to-previous-directory","text":"$ cd ..","title":"Go to previous directory"},{"location":"software/#home-directory","text":"$ cd","title":"Home directory"},{"location":"software/#remove-delete-a-file","text":"$ rm file_name","title":"Remove (delete) a file"},{"location":"software/#remove-directory","text":"$ rm -r directory_name","title":"Remove directory"},{"location":"software/#copy-file","text":"$ cp <source_file_location> <destination_file_location>","title":"Copy file"},{"location":"software/#copy-directory","text":"$ cp -r <source_dir_location> <destination_dir_location>","title":"Copy directory"},{"location":"software/#rename-or-move-file","text":"$ mv file1 file2","title":"Rename or Move file"},{"location":"software/#create-an-empty-file","text":"$ touch file_name","title":"Create an empty file"},{"location":"software/#view-contents-of-a-file","text":"$ cat file_name","title":"View contents of a file"},{"location":"software/#file-permissions","text":"PERMISSION TYPE COMMAND U G W rwx rwx rwx chmod 777 filename rwx rwx r-x chmod 775 filename rwx r-x r-x chmod 755 filename rw- rw- r-- chmod 664 filename rw- r-- r-- chmod 644 filename LEGEND U = User G = Group W = World r = Read w = write x = execute - = no access","title":"File Permissions"},{"location":"software/#networking","text":"","title":"Networking"},{"location":"software/#network-interfaces-and-ip-address","text":"$ ip a","title":"Network interfaces and IP address"},{"location":"software/#eth0-address-and-details","text":"$ ip addr show dev eth0","title":"eth0 address and details"},{"location":"software/#internet-connection-test","text":"$ ping www.google.com","title":"Internet connection test"},{"location":"software/#network-address-of-the-host","text":"$ hostname -i","title":"Network address of the host"},{"location":"software/#local-ip-addresses-of-host","text":"$ hostname -I","title":"Local IP addresses of host"},{"location":"software/#download","text":"$ wget http://domain.com/file","title":"Download"},{"location":"software/#archives-tar-files","text":"Create tar named archive.tar for the directory directory_name: $ tar cf archive.tar directory_name Extract the contents from archive.tar: $ tar xf archive.tar Create a gzip compressed tar file name archive.tar.gz: $ tar czf archive.tar.gz directory_name Extract a gzip compressed tar file: $ tar xzf archive.tar.gz Create a tar file with bzip2 compression: $ tar cjf archive.tar.bz2 directory_name Extract a bzip2 compressed tar file: $ tar xjf archive.tar.bz2 Extract xz file: $ tar -xf directory_name.tar.xz","title":"Archives (TAR FILES)"},{"location":"software/#installing-packages","text":"","title":"Installing Packages"},{"location":"software/#install-packagerpm","text":"$ rpm -i package.rpm","title":"Install package.rpm"},{"location":"software/#install-software-from-source-code","text":"$ tar zxvf sourcecode.tar.gz $ cd sourcecode $ ./configure $ make $ make install","title":"Install software from source code"},{"location":"software/#ssh-logins","text":"","title":"SSH Logins"},{"location":"software/#connect-to-host-as-user","text":"$ ssh user@host","title":"Connect to host as user"},{"location":"software/#connect-to-host-using-port","text":"$ ssh -p port user@host","title":"Connect to host using port"},{"location":"software/#file-transfers","text":"","title":"File Transfers"},{"location":"software/#secure-copy","text":"$ scp file.txt user@<server_ip_addr>:/usr/local","title":"Secure copy"},{"location":"software/#copy-files-from-server-to-local-machine","text":"$ scp user@<server_ip_addr>:/usr/local/*.txt /tmp","title":"Copy files from server to local machine"},{"location":"software/#copy-directories-from-server","text":"$ scp -r user@<server_ip_addr>:/usr/local/*.txt /tmp","title":"Copy directories from server"},{"location":"software/#synchronize","text":"$ rsync -a /home /backups/","title":"Synchronize"},{"location":"software/#sync-filesdirectories-between-local-and-remote-system","text":"$ rsync -avz /home user@<server_ip_addr>:/backups/","title":"Sync files/directories between local and remote system"},{"location":"software/#tmux-commands","text":"","title":"Tmux Commands"},{"location":"software/#start-tmux","text":"$ tmux","title":"Start tmux"},{"location":"software/#create-a-pane-to-the-side","text":"Ctrl+b+% (% for horizontal panes) Ctrl+b+\" ( \" for vertical panes)","title":"Create a pane to the side "},{"location":"software/#navigate-between-panes","text":"Ctrl+b+arrows","title":"Navigate between panes "},{"location":"software/#exit-a-pane","text":"$ exit","title":"Exit a pane"},{"location":"software/#kill-all-sessions","text":"$ tmux kill-server","title":"Kill all sessions"},{"location":"software/#new-tmux-window","text":"Ctrl+b+c (bottom bar displays new window number, * indicates active window)","title":"New tmux window "},{"location":"software/#switch-between-windows","text":"Ctrl+b+window_number \u21d2 Ctrl+b+1 or Ctrl+b+0","title":"Switch between windows "},{"location":"software/#rename-a-window","text":"Ctrl+b+, \u21d2 type name and hit Enter","title":"Rename a window "},{"location":"software/#detach-a-session","text":"Ctrl+d","title":"Detach a session "},{"location":"software/#view-sessions-running-in-background","text":"$ tmux ls","title":"View sessions running in background"},{"location":"software/#attach-a-session-to-tmux","text":"$ tmux attach -t <name_of_window> example: tmux attach -t 0","title":"Attach a session to tmux"},{"location":"software/#rename-a-session","text":"$ tmux rename-session -t <old_name> <new_name> example: tmux rename-session -t 0 git","title":"Rename a session"},{"location":"software/#create-a-new-session-with-name","text":"$ tmux new -s docker","title":"Create a new session with name"},{"location":"software/#kill-a-particular-session","text":"$ tmux kill-session -t <name_of_session> example: `tmux kill-session -t docker","title":"Kill a particular session"},{"location":"software/#resize-active-pane-border","text":"Hold Ctrl+b+arrow","title":"Resize active pane border "}]}